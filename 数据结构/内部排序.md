内部排序分为插入排序、选择排序、交换排序、归并排序、基数排序。

插入排序：

```
直接插入排序：稳定，时间复杂度O(n^2)
折半插入排序：稳定，时间复杂度O(n^2)
希尔排序：不稳定，时间复杂度最坏O(n^2),某个范围O(n^1.3)
```

选择排序(从后面的序列中选择一个最大或者最小值与所在序列中的第一个元素交换）：

```
简单选择排序：不安全(从后面的序列中选择一个最大或者最小值与所在序列中的第一个元素交换）
堆排序
```

交换排序：

```
冒泡排序：稳定，一趟中没有交换就停止，需要判断，平均时间复杂度为O(n^2)。
快速排序：不稳定，选择第一个元素为基准元素，利用low和high使所有元素与基准元素比较，先右，一趟排序实现基准元素左侧小右侧大，以同样方式递归实现左侧、右侧序列
```

归并排序：

基数排序：



外部排序算法的比较

一般基于三个因素进行对比：**时空复杂度、算法的稳定性、算法的过程特征**

从时间复杂度来看：简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为O(n^2)，且实现过程也比较简单，但是直接插入排序和冒泡排序最好情况下的时间复杂度可以达到O(n)，而简单排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但是目前位的初期精确的渐进时间。堆排序利用了一种称为堆的数据结构，可以在线性时间内完成建堆，且在O(nlogn)内完成排序过程。快速排序基于分治的思想，虽然最坏情况下快速排序时间会达到O(n^2),但是快速排序平均性能可以达到O(nlogn)，在实际应用中常常优于其他排序算法。归并排序同样是基于分治的思想，但是由于其分割子序列与初始化序列的排列无关，因此它的最好、最坏和平均时间复杂度为O(nlogn)。



## 插入排序

直接插入排序

（不带哨兵**i=1**开始）数组下标从0开始，**从第二个元素开始与第一个元素比较**

```c
void InsertSort(int A[],int n){
    int i,j,temp;
    for(i=1;i<n;i++){//将各元素插入已排好序的序列中
        if(A[i]<A[i-1])//若A[i]关键字小于前驱（前驱即为已排序中的最大值），否则i++往后走
            temp =A[i];//用temp暂存A[i]
            for(j=i-1;j>=0&&A[j]>temp;--j)//跳出排序时j对应插入位置的前面位置，所以要往后走j+1，j为已排序的最后一位，需确认j>=0，检查所有前面已排好的元素
                A[j+1]=A[j];//所有大于temp的已排序元素都向后移位
            A[j+1]=temp;//复制到插入位置,j为最后一次比较的位置，所以真正要放置在j+1的位置
    }
}
```

加哨兵(i=2开始)**因为有哨兵，所以第一个元素存在A[1]中**

```c
void InsertSort(int A[],int n){
    int i,j;
    for(i=2;i<=n;i++){//将各元素插入已排好序的序列中
        if(A[i]<A[i-1])//若A[i]关键字小于前驱（前驱即为已排序中的最大值），否则i++往后走
            A[0] =A[i];//复制A[i]为哨兵
            for(j=i-1;A[0]<A[j];--j)//j为已排序的最后一位，检查所有前面已排好的元素
                A[j+1]=A[j];//所有大于A[0]的已排序元素都向后移位
            A[j+1]=A[0];//复制到插入位置,j为最后一次比较的位置，所以真正要放置在j+1的位置
    }
}
```

优化-折半插入排序

插入到已经排好序的序列中

**low=1是因为下标为一是第一个元素**，mid值与插入值的比较保证**稳定性**

*没有比较要插入的元素与排序好的最后一个元素，如果比较的话是否会有更好的效果？*

```c
void InsertSort(int A[],int n){
    int i,j,low,high,mid;
    for(i=2;i<=n;i++){//将A[2]~A[n]插入已排好序的序列中，也是从第二个元素开始与前面的有序表比较
        A[0] =A[i];//复制A[i]为哨兵
        low=1;high=i-1;//设置折半查找的范围
        while(low<=high){//折半查找，默认递增有序
            mid=(low+high)/2;//取中间点
            if(A[mid]>A[0]) high=mid-1;//查有序表的左半子表
            else low=mid+1;//保证了稳定性，如果mid对应的元素值小于等于A[0](要插入的元素），查有序表的右半子表
        }
        for(j=i-1;j>=high+1;--j)//无论插入是左或右子表，插入位置的右侧元素都要右移
            A[j+1]=A[j];//所有大于A[0]的已排序元素都向后移位
        A[high+1]=A[0];//复制到插入位置,j为最后一次比较的位置，所以真正要放置在j+1的位置
    }
}
```

希尔排序

（代码中开始有n/2组，分组内使用直接插入排序，循环实现分组减半）

本代码中，希尔排序并不是每组独立排序后，再让下一组排序的，而是**每组轮流排序**，使用++i实现

```c
void ShellSort(int A[],int n){
    int d,i,j;
    for(d=n/2;d>=1;d=d/2)//每趟步长变化
        for(i=d+1;i<=n;++i)//d+1对应的位置为分组中的第二个元素，和上面的i=2意义一样
            if(A[i]<A[i-d]){
                A[0]=A[i];//A[0]作为temp暂存数据
                for(j=i-d;j>0&&A[0]<A[j];j-1=d)//j=j-d比较元素与所在分组前面的元素
                    A[j+d]=A[j];//小元素后移
                A[j+d]=A[0];//插入
            }
}
```



## 交换排序

冒泡排序

一趟：从后往前（或者从前往后比较），--i往前走，如果i比i-1小，交换，否则继续往前走。

空间复杂度O(1)，时间复杂度O(n^2)，稳定

```c
void swap(int &a,int &b){
    int temp = a;
    a = b;
    b = temp;
}

//冒泡排序
void BubbleSort(int A[],int n){
    for(int i=0;i<n-1;i++){
        bool flag=false;//是否发生交换的标志
        for(int j=n-1;j>i;j--)//j=n-1为最后一个元素，j>i是判断一趟结束的条件，上一趟排序到i-1的位置
            if(A[j-1]>A[j]){//若为逆序，只有前一个元素大于当前元素时才发生交换
                swap(A[j-1],A[j]);//交换
                falg=true;//显示发生交换
            }
        if(flag==false)
            return;//本趟遍历后没有发生交换，说明表已经有序
    }
}
```

快速排序

选择一个枢轴，进行一次**划分**后，左侧小右侧大，使用递归实现左右序列的快速排序

不稳定，时间复杂度O(nlogn)

```c
//快速排序
void QuickSort(int A[],int low,int high){
    if(low<high){//low>=high时跳出递归，比如只有一个元素的情况下（即最小的子表）
        int pivotpos=Partition(A,low,high);//进行划分，pivotpos即为枢轴元素的位置
        QuickSort(A,low,pivotpos-1);//划分左子表
        QuickSort(A,pivotpos-1,high);//划分右子表
    }
}

//用第一个元素将待排序序列划分成左右两个部分
int Partition(int A[],int low,int high){
    int pivot=A[low];//选择枢轴元素
    while(low<high){
        while(low<high&&A[high]>=pivot) --high;//当high大于枢轴时，不交换，high往左走
        A[low]=A[high];//移动元素
        while(low<high&&A[low]<=pivot) ++low;//当low小于等于枢轴时，不交换，low往右走
        A[high]=A[low];//比枢轴元素大的移到右侧
    }
    A[low]=pivot;//枢轴元素放到最终的位置，一般情况下，此时low==high
    return low;//返回存放枢轴的最终位置
}

```

